// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: charging_preferences.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAction = `-- name: CreateAction :exec
INSERT INTO actions (
  id, created_by, type, battery_charge,
  charge_if_price_below, discharge_if_price_above
) VALUES (
  $1, $2, $3, $4, $5, $6
)
`

type CreateActionParams struct {
	ID                    uuid.UUID      `db:"id"`
	CreatedBy             uuid.UUID      `db:"created_by"`
	Type                  ActionType     `db:"type"`
	BatteryCharge         pgtype.Int2    `db:"battery_charge"`
	ChargeIfPriceBelow    pgtype.Numeric `db:"charge_if_price_below"`
	DischargeIfPriceAbove pgtype.Numeric `db:"discharge_if_price_above"`
}

func (q *Queries) CreateAction(ctx context.Context, arg CreateActionParams) error {
	_, err := q.db.Exec(ctx, createAction,
		arg.ID,
		arg.CreatedBy,
		arg.Type,
		arg.BatteryCharge,
		arg.ChargeIfPriceBelow,
		arg.DischargeIfPriceAbove,
	)
	return err
}

const createChargingPreference = `-- name: CreateChargingPreference :exec
INSERT INTO charging_preferences (
  id, created_by, name, occurrence_id, date, action_id, priority
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
`

type CreateChargingPreferenceParams struct {
	ID           uuid.UUID   `db:"id"`
	CreatedBy    uuid.UUID   `db:"created_by"`
	Name         string      `db:"name"`
	OccurrenceID pgtype.UUID `db:"occurrence_id"`
	Date         pgtype.Date `db:"date"`
	ActionID     uuid.UUID   `db:"action_id"`
	Priority     int16       `db:"priority"`
}

func (q *Queries) CreateChargingPreference(ctx context.Context, arg CreateChargingPreferenceParams) error {
	_, err := q.db.Exec(ctx, createChargingPreference,
		arg.ID,
		arg.CreatedBy,
		arg.Name,
		arg.OccurrenceID,
		arg.Date,
		arg.ActionID,
		arg.Priority,
	)
	return err
}

const createOccurrence = `-- name: CreateOccurrence :exec
INSERT INTO occurrences (
  id, created_by, time, repeat, until, day_of_week, nth_of_month, day_of_month
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
`

type CreateOccurrenceParams struct {
	ID         uuid.UUID   `db:"id"`
	CreatedBy  uuid.UUID   `db:"created_by"`
	Time       pgtype.Time `db:"time"`
	Repeat     pgtype.Int4 `db:"repeat"`
	Until      pgtype.Date `db:"until"`
	DayOfWeek  NullWeekday `db:"day_of_week"`
	NthOfMonth NullOrdinal `db:"nth_of_month"`
	DayOfMonth pgtype.Int2 `db:"day_of_month"`
}

func (q *Queries) CreateOccurrence(ctx context.Context, arg CreateOccurrenceParams) error {
	_, err := q.db.Exec(ctx, createOccurrence,
		arg.ID,
		arg.CreatedBy,
		arg.Time,
		arg.Repeat,
		arg.Until,
		arg.DayOfWeek,
		arg.NthOfMonth,
		arg.DayOfMonth,
	)
	return err
}

const deleteAction = `-- name: DeleteAction :exec
DELETE FROM actions
WHERE id = $1
`

func (q *Queries) DeleteAction(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAction, id)
	return err
}

const deleteChargingPreference = `-- name: DeleteChargingPreference :exec
DELETE FROM charging_preferences
WHERE id = $1
`

func (q *Queries) DeleteChargingPreference(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteChargingPreference, id)
	return err
}

const deleteOccurrence = `-- name: DeleteOccurrence :exec
DELETE FROM occurrences
WHERE id = $1
`

func (q *Queries) DeleteOccurrence(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOccurrence, id)
	return err
}

const getChargingPreferencesByUserId = `-- name: GetChargingPreferencesByUserId :one
SELECT
  p.id AS preference_id,
  p.name,
  o.time,
  o.day_of_week,
  o.nth_of_month,
  o.day_of_month,
  o.repeat,
  o.until,
  a.type AS action_type,
  a.battery_charge,
  a.charge_if_price_below,
  a.discharge_if_price_above,
  p.priority,
  p.enabled
FROM charging_preferences p
LEFT JOIN occurrences o ON p.occurrence_id = o.id
JOIN actions a ON p.action_id = a.id
WHERE p.id = $1
`

type GetChargingPreferencesByUserIdRow struct {
	PreferenceID          uuid.UUID      `db:"preference_id"`
	Name                  string         `db:"name"`
	Time                  pgtype.Time    `db:"time"`
	DayOfWeek             NullWeekday    `db:"day_of_week"`
	NthOfMonth            NullOrdinal    `db:"nth_of_month"`
	DayOfMonth            pgtype.Int2    `db:"day_of_month"`
	Repeat                pgtype.Int4    `db:"repeat"`
	Until                 pgtype.Date    `db:"until"`
	ActionType            ActionType     `db:"action_type"`
	BatteryCharge         pgtype.Int2    `db:"battery_charge"`
	ChargeIfPriceBelow    pgtype.Numeric `db:"charge_if_price_below"`
	DischargeIfPriceAbove pgtype.Numeric `db:"discharge_if_price_above"`
	Priority              int16          `db:"priority"`
	Enabled               bool           `db:"enabled"`
}

func (q *Queries) GetChargingPreferencesByUserId(ctx context.Context, id uuid.UUID) (GetChargingPreferencesByUserIdRow, error) {
	row := q.db.QueryRow(ctx, getChargingPreferencesByUserId, id)
	var i GetChargingPreferencesByUserIdRow
	err := row.Scan(
		&i.PreferenceID,
		&i.Name,
		&i.Time,
		&i.DayOfWeek,
		&i.NthOfMonth,
		&i.DayOfMonth,
		&i.Repeat,
		&i.Until,
		&i.ActionType,
		&i.BatteryCharge,
		&i.ChargeIfPriceBelow,
		&i.DischargeIfPriceAbove,
		&i.Priority,
		&i.Enabled,
	)
	return i, err
}

const listActionsForUser = `-- name: ListActionsForUser :many
SELECT id, created_by, type, battery_charge, charge_if_price_below, discharge_if_price_above FROM actions
WHERE created_by = $1
`

func (q *Queries) ListActionsForUser(ctx context.Context, createdBy uuid.UUID) ([]Action, error) {
	rows, err := q.db.Query(ctx, listActionsForUser, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Action
	for rows.Next() {
		var i Action
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.Type,
			&i.BatteryCharge,
			&i.ChargeIfPriceBelow,
			&i.DischargeIfPriceAbove,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChargingPreferencesForUser = `-- name: ListChargingPreferencesForUser :many
SELECT
  p.id AS preference_id,
  p.name,
  o.time,
  o.day_of_week,
  o.nth_of_month,
  o.day_of_month,
  o.repeat,
  o.until,
  a.type AS action_type,
  a.battery_charge,
  a.charge_if_price_below,
  a.discharge_if_price_above,
  p.priority,
  p.enabled
FROM charging_preferences p
LEFT JOIN occurrences o ON p.occurrence_id = o.id
JOIN actions a ON p.action_id = a.id
WHERE p.created_by = $1
`

type ListChargingPreferencesForUserRow struct {
	PreferenceID          uuid.UUID      `db:"preference_id"`
	Name                  string         `db:"name"`
	Time                  pgtype.Time    `db:"time"`
	DayOfWeek             NullWeekday    `db:"day_of_week"`
	NthOfMonth            NullOrdinal    `db:"nth_of_month"`
	DayOfMonth            pgtype.Int2    `db:"day_of_month"`
	Repeat                pgtype.Int4    `db:"repeat"`
	Until                 pgtype.Date    `db:"until"`
	ActionType            ActionType     `db:"action_type"`
	BatteryCharge         pgtype.Int2    `db:"battery_charge"`
	ChargeIfPriceBelow    pgtype.Numeric `db:"charge_if_price_below"`
	DischargeIfPriceAbove pgtype.Numeric `db:"discharge_if_price_above"`
	Priority              int16          `db:"priority"`
	Enabled               bool           `db:"enabled"`
}

func (q *Queries) ListChargingPreferencesForUser(ctx context.Context, createdBy uuid.UUID) ([]ListChargingPreferencesForUserRow, error) {
	rows, err := q.db.Query(ctx, listChargingPreferencesForUser, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChargingPreferencesForUserRow
	for rows.Next() {
		var i ListChargingPreferencesForUserRow
		if err := rows.Scan(
			&i.PreferenceID,
			&i.Name,
			&i.Time,
			&i.DayOfWeek,
			&i.NthOfMonth,
			&i.DayOfMonth,
			&i.Repeat,
			&i.Until,
			&i.ActionType,
			&i.BatteryCharge,
			&i.ChargeIfPriceBelow,
			&i.DischargeIfPriceAbove,
			&i.Priority,
			&i.Enabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOccurrencesForUser = `-- name: ListOccurrencesForUser :many
SELECT id, created_by, time, repeat, until, day_of_week, nth_of_month, day_of_month FROM occurrences
WHERE created_by = $1
`

func (q *Queries) ListOccurrencesForUser(ctx context.Context, createdBy uuid.UUID) ([]Occurrence, error) {
	rows, err := q.db.Query(ctx, listOccurrencesForUser, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Occurrence
	for rows.Next() {
		var i Occurrence
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.Time,
			&i.Repeat,
			&i.Until,
			&i.DayOfWeek,
			&i.NthOfMonth,
			&i.DayOfMonth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
