// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: charging_preferences.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createChargingPolicies = `-- name: CreateChargingPolicies :exec
INSERT INTO charging_policies (
  id, min_charge, max_charge, charge_if_price_below, discharge_if_price_above
) VALUES ($1, $2, $3, $4, $5)
`

type CreateChargingPoliciesParams struct {
	ID                    uuid.UUID      `db:"id"`
	MinCharge             pgtype.Int2    `db:"min_charge"`
	MaxCharge             pgtype.Int2    `db:"max_charge"`
	ChargeIfPriceBelow    pgtype.Numeric `db:"charge_if_price_below"`
	DischargeIfPriceAbove pgtype.Numeric `db:"discharge_if_price_above"`
}

func (q *Queries) CreateChargingPolicies(ctx context.Context, arg CreateChargingPoliciesParams) error {
	_, err := q.db.Exec(ctx, createChargingPolicies,
		arg.ID,
		arg.MinCharge,
		arg.MaxCharge,
		arg.ChargeIfPriceBelow,
		arg.DischargeIfPriceAbove,
	)
	return err
}

const createChargingPreference = `-- name: CreateChargingPreference :exec
INSERT INTO charging_preferences (
  id, user_id, name, priority, enabled, charging_policy_id, keep_battery_at, one_time_occurrence_id, regular_occurrence_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateChargingPreferenceParams struct {
	ID                  uuid.UUID   `db:"id"`
	UserID              uuid.UUID   `db:"user_id"`
	Name                string      `db:"name"`
	Priority            int16       `db:"priority"`
	Enabled             bool        `db:"enabled"`
	ChargingPolicyID    pgtype.UUID `db:"charging_policy_id"`
	KeepBatteryAt       pgtype.Int2 `db:"keep_battery_at"`
	OneTimeOccurrenceID pgtype.UUID `db:"one_time_occurrence_id"`
	RegularOccurrenceID pgtype.UUID `db:"regular_occurrence_id"`
}

func (q *Queries) CreateChargingPreference(ctx context.Context, arg CreateChargingPreferenceParams) error {
	_, err := q.db.Exec(ctx, createChargingPreference,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Priority,
		arg.Enabled,
		arg.ChargingPolicyID,
		arg.KeepBatteryAt,
		arg.OneTimeOccurrenceID,
		arg.RegularOccurrenceID,
	)
	return err
}

const createOneTimeOccurrence = `-- name: CreateOneTimeOccurrence :exec
INSERT INTO one_time_occurrences (
  id, date_start, date_end
) VALUES ($1, $2, $3)
`

type CreateOneTimeOccurrenceParams struct {
	ID        uuid.UUID   `db:"id"`
	DateStart interface{} `db:"date_start"`
	DateEnd   interface{} `db:"date_end"`
}

func (q *Queries) CreateOneTimeOccurrence(ctx context.Context, arg CreateOneTimeOccurrenceParams) error {
	_, err := q.db.Exec(ctx, createOneTimeOccurrence, arg.ID, arg.DateStart, arg.DateEnd)
	return err
}

const createRegularOccurrence = `-- name: CreateRegularOccurrence :exec
INSERT INTO regular_occurrences (
  id,  time_of_day, repeat, until, day_of_week, nth_of_month, day_of_month
) VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateRegularOccurrenceParams struct {
	ID         uuid.UUID   `db:"id"`
	TimeOfDay  pgtype.Time `db:"time_of_day"`
	Repeat     pgtype.Int2 `db:"repeat"`
	Until      pgtype.Date `db:"until"`
	DayOfWeek  NullWeekday `db:"day_of_week"`
	NthOfMonth NullOrdinal `db:"nth_of_month"`
	DayOfMonth pgtype.Int2 `db:"day_of_month"`
}

func (q *Queries) CreateRegularOccurrence(ctx context.Context, arg CreateRegularOccurrenceParams) error {
	_, err := q.db.Exec(ctx, createRegularOccurrence,
		arg.ID,
		arg.TimeOfDay,
		arg.Repeat,
		arg.Until,
		arg.DayOfWeek,
		arg.NthOfMonth,
		arg.DayOfMonth,
	)
	return err
}

const deleteChargingPolicies = `-- name: DeleteChargingPolicies :exec
DELETE FROM charging_policies
WHERE id = $1
`

func (q *Queries) DeleteChargingPolicies(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteChargingPolicies, id)
	return err
}

const deleteChargingPreference = `-- name: DeleteChargingPreference :exec
DELETE FROM charging_preferences
WHERE id = $1
`

func (q *Queries) DeleteChargingPreference(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteChargingPreference, id)
	return err
}

const deleteOneTimeOccurrence = `-- name: DeleteOneTimeOccurrence :exec
DELETE FROM one_time_occurrences
WHERE id = $1
`

func (q *Queries) DeleteOneTimeOccurrence(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOneTimeOccurrence, id)
	return err
}

const deleteRegularOccurrences = `-- name: DeleteRegularOccurrences :exec
DELETE FROM regular_occurrences
WHERE id = $1
`

func (q *Queries) DeleteRegularOccurrences(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRegularOccurrences, id)
	return err
}

const listChargingPreferencesForUser = `-- name: ListChargingPreferencesForUser :many
SELECT
  p.id AS preference_id,
  p.user_id,
  p.name,
  p.priority,
  p.enabled,
  oo.date_start,
  oo.date_end,
  ro.time_of_day,
  ro.day_of_week,
  ro.nth_of_month,
  ro.day_of_month,
  ro.repeat,
  ro.until,
  cp.min_charge,
  cp.max_charge,
  cp.charge_if_price_below,
  cp.discharge_if_price_above
FROM charging_preferences p
LEFT JOIN regular_occurrences ro ON p.regular_occurrence_id = ro.id
LEFT JOIN one_time_occurrences oo ON p.one_time_occurrence_id = oo.id
LEFT JOIN charging_policies cp ON p.charging_policy_id = cp.id
WHERE p.user_id = $1
`

type ListChargingPreferencesForUserRow struct {
	PreferenceID          uuid.UUID      `db:"preference_id"`
	UserID                uuid.UUID      `db:"user_id"`
	Name                  string         `db:"name"`
	Priority              int16          `db:"priority"`
	Enabled               bool           `db:"enabled"`
	DateStart             interface{}    `db:"date_start"`
	DateEnd               interface{}    `db:"date_end"`
	TimeOfDay             pgtype.Time    `db:"time_of_day"`
	DayOfWeek             NullWeekday    `db:"day_of_week"`
	NthOfMonth            NullOrdinal    `db:"nth_of_month"`
	DayOfMonth            pgtype.Int2    `db:"day_of_month"`
	Repeat                pgtype.Int2    `db:"repeat"`
	Until                 pgtype.Date    `db:"until"`
	MinCharge             pgtype.Int2    `db:"min_charge"`
	MaxCharge             pgtype.Int2    `db:"max_charge"`
	ChargeIfPriceBelow    pgtype.Numeric `db:"charge_if_price_below"`
	DischargeIfPriceAbove pgtype.Numeric `db:"discharge_if_price_above"`
}

func (q *Queries) ListChargingPreferencesForUser(ctx context.Context, userID uuid.UUID) ([]ListChargingPreferencesForUserRow, error) {
	rows, err := q.db.Query(ctx, listChargingPreferencesForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChargingPreferencesForUserRow
	for rows.Next() {
		var i ListChargingPreferencesForUserRow
		if err := rows.Scan(
			&i.PreferenceID,
			&i.UserID,
			&i.Name,
			&i.Priority,
			&i.Enabled,
			&i.DateStart,
			&i.DateEnd,
			&i.TimeOfDay,
			&i.DayOfWeek,
			&i.NthOfMonth,
			&i.DayOfMonth,
			&i.Repeat,
			&i.Until,
			&i.MinCharge,
			&i.MaxCharge,
			&i.ChargeIfPriceBelow,
			&i.DischargeIfPriceAbove,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
